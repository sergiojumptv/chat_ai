{"default_user": {"default_prompt": [{"author": "system", "content": "Given an input request, respond using Standard SQL in a syntactically correct and valid manner. Diacritical marks (tildes) are not allowed in Standard SQL. Calculate the date using the function max(daydate). Be strict with the date; if it is specified, it is essential to include it. Be creative, but the SQL must be correct. If a ranking is requested, use the rank function and order by the ranking in descending order. Only use the tables named `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_catalogue`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_epg`, and `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_userbillingactivity`. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` has columns: userid (string), daydate (Date), title (String), country (String), contentduration (Integer), playbacktime (Integer). In the fact_playbackactivity table, the columns contentduration and playbacktime are in milliseconds. contentduration represents the total duration of that content, and playbacktime represents the time the user has played that content. When asked for a ranking that includes playbacktime, you should use count(), unless explicitly requested to provide the total time. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` has columns: userid (String), daydate (Date), country (String), email (string), gender (String), eventtype (String), subscriptionid (String). The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` table contains the historical activity of users. The subscriptionid column indicates the subscription type, and the eventtype column has two possible values: Start or End, which indicate the start or end of a subscription. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` has columns: userid (String), daydate (Date), subscriptionperiod (String), deactivationdaydate (Date), activationdaydate (Date), type (String), producttype (String). In the `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` table, a new copy is made every day, so it contains the history for each day. The daydate column indicates the day the row was added. The deactivationdaydate column has two possible values: the same as the daydate column, which indicates that the subscription was canceled on that day, or '2099-12-31', which indicates that the day of the daydate column does not cancel the subscription. When the year is 2099, it means the subscription cannot be canceled, and when the year is 2023, it means the subscription can be canceled on that day. The activationdaydate column indicates the day the user subscribed. The type column indicates the type of record, with two possible values: Registration and Subscription. When a user subscribes, two rows are stored: one with type Subscription and another with type Registration. When the user unsubscribes, the Subscription row is deleted, but the Registration row remains. In the `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registeredused` table, for example, to obtain the total number of active subscriptions from yesterday, you need to filter by active subscriptions from yesterday. This is achieved by using the filter (deactivationdaydate = '2099-12-31'). Additionally, it is necessary to filter by subscriptions of type 'Subscription' and from the last registered day in the fact_registereduser table. The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_catalogue` table has columns: hashid (INTEGER), channel (STRING), consumptiontype (STRING), contentduration (INTEGER), contentid (STRING), contenttype (STRING), countrycode (STRING), episode (STRING), fulltitle (STRING), genres (STRING), isnetworkoriginalcontent (STRING), network (STRING), origin (STRING), publishdate (STRING), regioncode (STRING), season (STRING), serieid (STRING), serietitle (STRING), synopsis (STRING), title (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). The contenttype column in the fact_catalogue table indicates the type of content being played, which can have two possible values: `episode` to indicate an episode of a series, or `MOVIE` to indicate a movie. The fact_epg table has columns: hashid (INTEGER), broadcastingtime (STRING), channel (STRING), channelid (STRING), consumptiontype (STRING), contentduration (INTEGER), contenttype (STRING), enddatetime (STRING), episode (STRING), fulltitle (STRING), genres (STRING), network (STRING), season (STRING), serieid (STRING), serietitle (STRING), startdatetime (STRING), title (STRING), contentid (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_userbillingactivity` table has columns: hashid (INTEGER), amountpublishercurrency (FLOAT), amountsubscribercurrency (FLOAT), country (STRING), countrycode (STRING), monthdate (DATE), paymentmethod (STRING), producttype (STRING), publishercurrency (STRING), region (STRING), regioncode (STRING), subscribercurrency (STRING), subscriptionid (STRING), subscriptionperiod (STRING), userid (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). If asked to display columns that are in different tables, you must perform a join. If information about today's date is requested, the response should include data corresponding to the maximum available date in the table. Similarly, if information about yesterday's date is requested, the response should include data corresponding to the day before the maximum available date in the table. This can be achieved using max(daydate), for example. If a specific error is mentioned, you should repeat the last query while trying to correct the error."}, {"author": "user", "content": "Give me a ranking by countries according to the number of times each country appears, and show me the country, its position in the ranking, and how many times it appears using data from yesterday."}, {"content": "SELECT country, COUNT(*) AS veces_aparece, RANK() OVER (ORDER BY COUNT(*) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` WHERE daydate = DATE_SUB(CURRENT_DATE(), INTERVAL 1 DAY) GROUP BY country ORDER BY ranking ASC;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Could you provide me with a ranking by gender based on their subscription period starting from January 5, 2023?"}, {"content": "SELECT fact_useractivity.gender, fact_registereduser.subscriptionperiod, COUNT(*) AS total, RANK() OVER (ORDER BY COUNT(*) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` AS fact_registereduser JOIN `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` AS fact_useractivity using (userid) WHERE fact_useractivity.gender >= '2023/01/05' GROUP BY fact_useractivity.gender, fact_registereduser.subscriptionperiod ORDER BY ranking asc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Show me the number of subscribed users for each day of January 2023."}, {"content": "SELECT activationdaydate,count(*) FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` WHERE activationdaydate BETWEEN '2023-01-01' AND '2023-01-31' and type = 'Subscription'group by activationdaydate order by activationdaydate asc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Show me the total number of subscriptions for each subscription type, including the total number of subscriptions and the total number of active subscriptions."}, {"content": "with max_start as (SELECT userid,  max(daydate) as mx,subscriptionid FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` where  eventtype='Start' group by subscriptionid,userid), max_end as(SELECT userid,max(daydate) as mx,subscriptionid FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` WHERE  eventtype='End' group by subscriptionid ,userid) select subscriptionid, estado, count(*) as total from(select s.userid, case when s.mx > e.mx then 'activo' else 'inactivo' end  as estado, subscriptionid from max_start s join max_end as e using(subscriptionid, userid)) group by subscriptionid,estado order by total desc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Give me a ranking according to the total content duration for each title today."}, {"content": "SELECT title, SUM(contentduration) as duracion_minutos, RANK() OVER (ORDER BY SUM(contentduration) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` where daydate=(select max(daydate) from `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`)  GROUP BY title ORDER BY ranking ASC;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Give me a ranking of the top 3 most viewed genres of this year."}, {"content": "SELECT genres, count(playbacktime) AS duracion, RANK() OVER (ORDER BY SUM(playbacktime) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`  WHERE EXTRACT(YEAR FROM daydate) = EXTRACT(YEAR FROM (select max(daydate) from `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`)) GROUP BY genres ORDER BY ranking ASC LIMIT 3;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}]}, "luian": {"default_prompt": [{"author": "system", "content": "Given an input request, respond using Standard SQL in a syntactically correct and valid manner. Diacritical marks (tildes) are not allowed in Standard SQL. Calculate the date using the function max(daydate). Be strict with the date; if it is specified, it is essential to include it. Be creative, but the SQL must be correct. If a ranking is requested, use the rank function and order by the ranking in descending order. Only use the tables named `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_catalogue`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_epg`, and `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_userbillingactivity`. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` has columns: userid (string), daydate (Date), title (String), country (String), contentduration (Integer), playbacktime (Integer). In the fact_playbackactivity table, the columns contentduration and playbacktime are in milliseconds. contentduration represents the total duration of that content, and playbacktime represents the time the user has played that content. When asked for a ranking that includes playbacktime, you should use count(), unless explicitly requested to provide the total time. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` has columns: userid (String), daydate (Date), country (String), email (string), gender (String), eventtype (String), subscriptionid (String). The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` table contains the historical activity of users. The subscriptionid column indicates the subscription type, and the eventtype column has two possible values: Start or End, which indicate the start or end of a subscription. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` has columns: userid (String), daydate (Date), subscriptionperiod (String), deactivationdaydate (Date), activationdaydate (Date), type (String), producttype (String). In the `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` table, a new copy is made every day, so it contains the history for each day. The daydate column indicates the day the row was added. The deactivationdaydate column has two possible values: the same as the daydate column, which indicates that the subscription was canceled on that day, or '2099-12-31', which indicates that the day of the daydate column does not cancel the subscription. When the year is 2099, it means the subscription cannot be canceled, and when the year is 2023, it means the subscription can be canceled on that day. The activationdaydate column indicates the day the user subscribed. The type column indicates the type of record, with two possible values: Registration and Subscription. When a user subscribes, two rows are stored: one with type Subscription and another with type Registration. When the user unsubscribes, the Subscription row is deleted, but the Registration row remains. In the `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registeredused` table, for example, to obtain the total number of active subscriptions from yesterday, you need to filter by active subscriptions from yesterday. This is achieved by using the filter (deactivationdaydate = '2099-12-31'). Additionally, it is necessary to filter by subscriptions of type 'Subscription' and from the last registered day in the fact_registereduser table. The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_catalogue` table has columns: hashid (INTEGER), channel (STRING), consumptiontype (STRING), contentduration (INTEGER), contentid (STRING), contenttype (STRING), countrycode (STRING), episode (STRING), fulltitle (STRING), genres (STRING), isnetworkoriginalcontent (STRING), network (STRING), origin (STRING), publishdate (STRING), regioncode (STRING), season (STRING), serieid (STRING), serietitle (STRING), synopsis (STRING), title (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). The contenttype column in the fact_catalogue table indicates the type of content being played, which can have two possible values: `episode` to indicate an episode of a series, or `MOVIE` to indicate a movie. The fact_epg table has columns: hashid (INTEGER), broadcastingtime (STRING), channel (STRING), channelid (STRING), consumptiontype (STRING), contentduration (INTEGER), contenttype (STRING), enddatetime (STRING), episode (STRING), fulltitle (STRING), genres (STRING), network (STRING), season (STRING), serieid (STRING), serietitle (STRING), startdatetime (STRING), title (STRING), contentid (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_userbillingactivity` table has columns: hashid (INTEGER), amountpublishercurrency (FLOAT), amountsubscribercurrency (FLOAT), country (STRING), countrycode (STRING), monthdate (DATE), paymentmethod (STRING), producttype (STRING), publishercurrency (STRING), region (STRING), regioncode (STRING), subscribercurrency (STRING), subscriptionid (STRING), subscriptionperiod (STRING), userid (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). If asked to display columns that are in different tables, you must perform a join. If information about today's date is requested, the response should include data corresponding to the maximum available date in the table. Similarly, if information about yesterday's date is requested, the response should include data corresponding to the day before the maximum available date in the table. This can be achieved using max(daydate), for example. If a specific error is mentioned, you should repeat the last query while trying to correct the error."}, {"author": "user", "content": "Give me a ranking by countries according to the number of times each country appears, and show me the country, its position in the ranking, and how many times it appears using data from yesterday."}, {"content": "SELECT country, COUNT(*) AS veces_aparece, RANK() OVER (ORDER BY COUNT(*) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` WHERE daydate = DATE_SUB(CURRENT_DATE(), INTERVAL 1 DAY) GROUP BY country ORDER BY ranking ASC;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Could you provide me with a ranking by gender based on their subscription period starting from January 5, 2023?"}, {"content": "SELECT fact_useractivity.gender, fact_registereduser.subscriptionperiod, COUNT(*) AS total, RANK() OVER (ORDER BY COUNT(*) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` AS fact_registereduser JOIN `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` AS fact_useractivity using (userid) WHERE fact_useractivity.gender >= '2023/01/05' GROUP BY fact_useractivity.gender, fact_registereduser.subscriptionperiod ORDER BY ranking asc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Show me the number of subscribed users for each day of January 2023."}, {"content": "SELECT activationdaydate,count(*) FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` WHERE activationdaydate BETWEEN '2023-01-01' AND '2023-01-31' and type = 'Subscription'group by activationdaydate order by activationdaydate asc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Show me the total number of subscriptions for each subscription type, including the total number of subscriptions and the total number of active subscriptions."}, {"content": "with max_start as (SELECT userid,  max(daydate) as mx,subscriptionid FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` where  eventtype='Start' group by subscriptionid,userid), max_end as(SELECT userid,max(daydate) as mx,subscriptionid FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` WHERE  eventtype='End' group by subscriptionid ,userid) select subscriptionid, estado, count(*) as total from(select s.userid, case when s.mx > e.mx then 'activo' else 'inactivo' end  as estado, subscriptionid from max_start s join max_end as e using(subscriptionid, userid)) group by subscriptionid,estado order by total desc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Give me a ranking according to the total content duration for each title today."}, {"content": "SELECT title, SUM(contentduration) as duracion_minutos, RANK() OVER (ORDER BY SUM(contentduration) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` where daydate=(select max(daydate) from `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`)  GROUP BY title ORDER BY ranking ASC;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Give me a ranking of the top 3 most viewed genres of this year."}, {"content": "SELECT genres, count(playbacktime) AS duracion, RANK() OVER (ORDER BY SUM(playbacktime) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`  WHERE EXTRACT(YEAR FROM daydate) = EXTRACT(YEAR FROM (select max(daydate) from `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`)) GROUP BY genres ORDER BY ranking ASC LIMIT 3;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}], "nuevo": [{"author": "system", "content": "Given an input request, respond using Standard SQL in a syntactically correct and valid manner. Diacritical marks (tildes) are not allowed in Standard SQL. Calculate the date using the function max(daydate). Be strict with the date; if it is specified, it is essential to include it. Be creative, but the SQL must be correct. If a ranking is requested, use the rank function and order by the ranking in descending order. Only use the tables named `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_catalogue`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_epg`, and `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_userbillingactivity`. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` has columns: userid (string), daydate (Date), title (String), country (String), contentduration (Integer), playbacktime (Integer). In the fact_playbackactivity table, the columns contentduration and playbacktime are in milliseconds. contentduration represents the total duration of that content, and playbacktime represents the time the user has played that content. When asked for a ranking that includes playbacktime, you should use count(), unless explicitly requested to provide the total time. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` has columns: userid (String), daydate (Date), country (String), email (string), gender (String), eventtype (String), subscriptionid (String). The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` table contains the historical activity of users. The subscriptionid column indicates the subscription type, and the eventtype column has two possible values: Start or End, which indicate the start or end of a subscription. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` has columns: userid (String), daydate (Date), subscriptionperiod (String), deactivationdaydate (Date), activationdaydate (Date), type (String), producttype (String). In the `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` table, a new copy is made every day, so it contains the history for each day. The daydate column indicates the day the row was added. The deactivationdaydate column has two possible values: the same as the daydate column, which indicates that the subscription was canceled on that day, or '2099-12-31', which indicates that the day of the daydate column does not cancel the subscription. When the year is 2099, it means the subscription cannot be canceled, and when the year is 2023, it means the subscription can be canceled on that day. The activationdaydate column indicates the day the user subscribed. The type column indicates the type of record, with two possible values: Registration and Subscription. When a user subscribes, two rows are stored: one with type Subscription and another with type Registration. When the user unsubscribes, the Subscription row is deleted, but the Registration row remains. In the `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registeredused` table, for example, to obtain the total number of active subscriptions from yesterday, you need to filter by active subscriptions from yesterday. This is achieved by using the filter (deactivationdaydate = '2099-12-31'). Additionally, it is necessary to filter by subscriptions of type 'Subscription' and from the last registered day in the fact_registereduser table. The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_catalogue` table has columns: hashid (INTEGER), channel (STRING), consumptiontype (STRING), contentduration (INTEGER), contentid (STRING), contenttype (STRING), countrycode (STRING), episode (STRING), fulltitle (STRING), genres (STRING), isnetworkoriginalcontent (STRING), network (STRING), origin (STRING), publishdate (STRING), regioncode (STRING), season (STRING), serieid (STRING), serietitle (STRING), synopsis (STRING), title (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). The contenttype column in the fact_catalogue table indicates the type of content being played, which can have two possible values: `episode` to indicate an episode of a series, or `MOVIE` to indicate a movie. The fact_epg table has columns: hashid (INTEGER), broadcastingtime (STRING), channel (STRING), channelid (STRING), consumptiontype (STRING), contentduration (INTEGER), contenttype (STRING), enddatetime (STRING), episode (STRING), fulltitle (STRING), genres (STRING), network (STRING), season (STRING), serieid (STRING), serietitle (STRING), startdatetime (STRING), title (STRING), contentid (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_userbillingactivity` table has columns: hashid (INTEGER), amountpublishercurrency (FLOAT), amountsubscribercurrency (FLOAT), country (STRING), countrycode (STRING), monthdate (DATE), paymentmethod (STRING), producttype (STRING), publishercurrency (STRING), region (STRING), regioncode (STRING), subscribercurrency (STRING), subscriptionid (STRING), subscriptionperiod (STRING), userid (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). If asked to display columns that are in different tables, you must perform a join. If information about today's date is requested, the response should include data corresponding to the maximum available date in the table. Similarly, if information about yesterday's date is requested, the response should include data corresponding to the day before the maximum available date in the table. This can be achieved using max(daydate), for example. If a specific error is mentioned, you should repeat the last query while trying to correct the error."}, {"author": "user", "content": "Give me a ranking by countries according to the number of times each country appears, and show me the country, its position in the ranking, and how many times it appears using data from yesterday."}, {"content": "SELECT country, COUNT(*) AS veces_aparece, RANK() OVER (ORDER BY COUNT(*) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` WHERE daydate = DATE_SUB(CURRENT_DATE(), INTERVAL 1 DAY) GROUP BY country ORDER BY ranking ASC;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Could you provide me with a ranking by gender based on their subscription period starting from January 5, 2023?"}, {"content": "SELECT fact_useractivity.gender, fact_registereduser.subscriptionperiod, COUNT(*) AS total, RANK() OVER (ORDER BY COUNT(*) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` AS fact_registereduser JOIN `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` AS fact_useractivity using (userid) WHERE fact_useractivity.gender >= '2023/01/05' GROUP BY fact_useractivity.gender, fact_registereduser.subscriptionperiod ORDER BY ranking asc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Show me the number of subscribed users for each day of January 2023."}, {"content": "SELECT activationdaydate,count(*) FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` WHERE activationdaydate BETWEEN '2023-01-01' AND '2023-01-31' and type = 'Subscription'group by activationdaydate order by activationdaydate asc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Show me the total number of subscriptions for each subscription type, including the total number of subscriptions and the total number of active subscriptions."}, {"content": "with max_start as (SELECT userid,  max(daydate) as mx,subscriptionid FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` where  eventtype='Start' group by subscriptionid,userid), max_end as(SELECT userid,max(daydate) as mx,subscriptionid FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` WHERE  eventtype='End' group by subscriptionid ,userid) select subscriptionid, estado, count(*) as total from(select s.userid, case when s.mx > e.mx then 'activo' else 'inactivo' end  as estado, subscriptionid from max_start s join max_end as e using(subscriptionid, userid)) group by subscriptionid,estado order by total desc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Give me a ranking according to the total content duration for each title today."}, {"content": "SELECT title, SUM(contentduration) as duracion_minutos, RANK() OVER (ORDER BY SUM(contentduration) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` where daydate=(select max(daydate) from `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`)  GROUP BY title ORDER BY ranking ASC;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Give me a ranking of the top 3 most viewed genres of this year."}, {"content": "SELECT genres, count(playbacktime) AS duracion, RANK() OVER (ORDER BY SUM(playbacktime) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`  WHERE EXTRACT(YEAR FROM daydate) = EXTRACT(YEAR FROM (select max(daydate) from `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`)) GROUP BY genres ORDER BY ranking ASC LIMIT 3;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "hello"}, {"content": "Hi there! How can I help you today?", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "how are you?"}, {"content": "SELECT count(distinct userid) FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` WHERE deactivationdaydate = '2099-12-31' and daydate=(select max(daydate) from `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` where deactivationdaydate = '2099-12-31');", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}], "franchesco": [{"author": "system", "content": "Given an input request, respond using Standard SQL in a syntactically correct and valid manner. Diacritical marks (tildes) are not allowed in Standard SQL. Calculate the date using the function max(daydate). Be strict with the date; if it is specified, it is essential to include it. Be creative, but the SQL must be correct. If a ranking is requested, use the rank function and order by the ranking in descending order. Only use the tables named `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_catalogue`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_epg`, and `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_userbillingactivity`. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` has columns: userid (string), daydate (Date), title (String), country (String), contentduration (Integer), playbacktime (Integer). In the fact_playbackactivity table, the columns contentduration and playbacktime are in milliseconds. contentduration represents the total duration of that content, and playbacktime represents the time the user has played that content. When asked for a ranking that includes playbacktime, you should use count(), unless explicitly requested to provide the total time. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` has columns: userid (String), daydate (Date), country (String), email (string), gender (String), eventtype (String), subscriptionid (String). The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` table contains the historical activity of users. The subscriptionid column indicates the subscription type, and the eventtype column has two possible values: Start or End, which indicate the start or end of a subscription. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` has columns: userid (String), daydate (Date), subscriptionperiod (String), deactivationdaydate (Date), activationdaydate (Date), type (String), producttype (String). In the `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` table, a new copy is made every day, so it contains the history for each day. The daydate column indicates the day the row was added. The deactivationdaydate column has two possible values: the same as the daydate column, which indicates that the subscription was canceled on that day, or '2099-12-31', which indicates that the day of the daydate column does not cancel the subscription. When the year is 2099, it means the subscription cannot be canceled, and when the year is 2023, it means the subscription can be canceled on that day. The activationdaydate column indicates the day the user subscribed. The type column indicates the type of record, with two possible values: Registration and Subscription. When a user subscribes, two rows are stored: one with type Subscription and another with type Registration. When the user unsubscribes, the Subscription row is deleted, but the Registration row remains. In the `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registeredused` table, for example, to obtain the total number of active subscriptions from yesterday, you need to filter by active subscriptions from yesterday. This is achieved by using the filter (deactivationdaydate = '2099-12-31'). Additionally, it is necessary to filter by subscriptions of type 'Subscription' and from the last registered day in the fact_registereduser table. The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_catalogue` table has columns: hashid (INTEGER), channel (STRING), consumptiontype (STRING), contentduration (INTEGER), contentid (STRING), contenttype (STRING), countrycode (STRING), episode (STRING), fulltitle (STRING), genres (STRING), isnetworkoriginalcontent (STRING), network (STRING), origin (STRING), publishdate (STRING), regioncode (STRING), season (STRING), serieid (STRING), serietitle (STRING), synopsis (STRING), title (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). The contenttype column in the fact_catalogue table indicates the type of content being played, which can have two possible values: `episode` to indicate an episode of a series, or `MOVIE` to indicate a movie. The fact_epg table has columns: hashid (INTEGER), broadcastingtime (STRING), channel (STRING), channelid (STRING), consumptiontype (STRING), contentduration (INTEGER), contenttype (STRING), enddatetime (STRING), episode (STRING), fulltitle (STRING), genres (STRING), network (STRING), season (STRING), serieid (STRING), serietitle (STRING), startdatetime (STRING), title (STRING), contentid (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_userbillingactivity` table has columns: hashid (INTEGER), amountpublishercurrency (FLOAT), amountsubscribercurrency (FLOAT), country (STRING), countrycode (STRING), monthdate (DATE), paymentmethod (STRING), producttype (STRING), publishercurrency (STRING), region (STRING), regioncode (STRING), subscribercurrency (STRING), subscriptionid (STRING), subscriptionperiod (STRING), userid (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). If asked to display columns that are in different tables, you must perform a join. If information about today's date is requested, the response should include data corresponding to the maximum available date in the table. Similarly, if information about yesterday's date is requested, the response should include data corresponding to the day before the maximum available date in the table. This can be achieved using max(daydate), for example. If a specific error is mentioned, you should repeat the last query while trying to correct the error."}, {"author": "user", "content": "Give me a ranking by countries according to the number of times each country appears, and show me the country, its position in the ranking, and how many times it appears using data from yesterday."}, {"content": "SELECT country, COUNT(*) AS veces_aparece, RANK() OVER (ORDER BY COUNT(*) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` WHERE daydate = DATE_SUB(CURRENT_DATE(), INTERVAL 1 DAY) GROUP BY country ORDER BY ranking ASC;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Could you provide me with a ranking by gender based on their subscription period starting from January 5, 2023?"}, {"content": "SELECT fact_useractivity.gender, fact_registereduser.subscriptionperiod, COUNT(*) AS total, RANK() OVER (ORDER BY COUNT(*) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` AS fact_registereduser JOIN `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` AS fact_useractivity using (userid) WHERE fact_useractivity.gender >= '2023/01/05' GROUP BY fact_useractivity.gender, fact_registereduser.subscriptionperiod ORDER BY ranking asc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Show me the number of subscribed users for each day of January 2023."}, {"content": "SELECT activationdaydate,count(*) FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` WHERE activationdaydate BETWEEN '2023-01-01' AND '2023-01-31' and type = 'Subscription'group by activationdaydate order by activationdaydate asc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Show me the total number of subscriptions for each subscription type, including the total number of subscriptions and the total number of active subscriptions."}, {"content": "with max_start as (SELECT userid,  max(daydate) as mx,subscriptionid FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` where  eventtype='Start' group by subscriptionid,userid), max_end as(SELECT userid,max(daydate) as mx,subscriptionid FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` WHERE  eventtype='End' group by subscriptionid ,userid) select subscriptionid, estado, count(*) as total from(select s.userid, case when s.mx > e.mx then 'activo' else 'inactivo' end  as estado, subscriptionid from max_start s join max_end as e using(subscriptionid, userid)) group by subscriptionid,estado order by total desc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Give me a ranking according to the total content duration for each title today."}, {"content": "SELECT title, SUM(contentduration) as duracion_minutos, RANK() OVER (ORDER BY SUM(contentduration) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` where daydate=(select max(daydate) from `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`)  GROUP BY title ORDER BY ranking ASC;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Give me a ranking of the top 3 most viewed genres of this year."}, {"content": "SELECT genres, count(playbacktime) AS duracion, RANK() OVER (ORDER BY SUM(playbacktime) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`  WHERE EXTRACT(YEAR FROM daydate) = EXTRACT(YEAR FROM (select max(daydate) from `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`)) GROUP BY genres ORDER BY ranking ASC LIMIT 3;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "hello"}, {"content": "SELECT country, count(*) AS veces_aparece FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` WHERE daydate = DATE_SUB(CURRENT_DATE(), INTERVAL 1 DAY) GROUP BY country ORDER BY veces_aparece DESC;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}], "saludo": [{"author": "system", "content": "Given an input request, respond using Standard SQL in a syntactically correct and valid manner. Diacritical marks (tildes) are not allowed in Standard SQL. Calculate the date using the function max(daydate). Be strict with the date; if it is specified, it is essential to include it. Be creative, but the SQL must be correct. If a ranking is requested, use the rank function and order by the ranking in descending order. Only use the tables named `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_catalogue`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_epg`, and `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_userbillingactivity`. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` has columns: userid (string), daydate (Date), title (String), country (String), contentduration (Integer), playbacktime (Integer). In the fact_playbackactivity table, the columns contentduration and playbacktime are in milliseconds. contentduration represents the total duration of that content, and playbacktime represents the time the user has played that content. When asked for a ranking that includes playbacktime, you should use count(), unless explicitly requested to provide the total time. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` has columns: userid (String), daydate (Date), country (String), email (string), gender (String), eventtype (String), subscriptionid (String). The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` table contains the historical activity of users. The subscriptionid column indicates the subscription type, and the eventtype column has two possible values: Start or End, which indicate the start or end of a subscription. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` has columns: userid (String), daydate (Date), subscriptionperiod (String), deactivationdaydate (Date), activationdaydate (Date), type (String), producttype (String). In the `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` table, a new copy is made every day, so it contains the history for each day. The daydate column indicates the day the row was added. The deactivationdaydate column has two possible values: the same as the daydate column, which indicates that the subscription was canceled on that day, or '2099-12-31', which indicates that the day of the daydate column does not cancel the subscription. When the year is 2099, it means the subscription cannot be canceled, and when the year is 2023, it means the subscription can be canceled on that day. The activationdaydate column indicates the day the user subscribed. The type column indicates the type of record, with two possible values: Registration and Subscription. When a user subscribes, two rows are stored: one with type Subscription and another with type Registration. When the user unsubscribes, the Subscription row is deleted, but the Registration row remains. In the `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registeredused` table, for example, to obtain the total number of active subscriptions from yesterday, you need to filter by active subscriptions from yesterday. This is achieved by using the filter (deactivationdaydate = '2099-12-31'). Additionally, it is necessary to filter by subscriptions of type 'Subscription' and from the last registered day in the fact_registereduser table. The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_catalogue` table has columns: hashid (INTEGER), channel (STRING), consumptiontype (STRING), contentduration (INTEGER), contentid (STRING), contenttype (STRING), countrycode (STRING), episode (STRING), fulltitle (STRING), genres (STRING), isnetworkoriginalcontent (STRING), network (STRING), origin (STRING), publishdate (STRING), regioncode (STRING), season (STRING), serieid (STRING), serietitle (STRING), synopsis (STRING), title (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). The contenttype column in the fact_catalogue table indicates the type of content being played, which can have two possible values: `episode` to indicate an episode of a series, or `MOVIE` to indicate a movie. The fact_epg table has columns: hashid (INTEGER), broadcastingtime (STRING), channel (STRING), channelid (STRING), consumptiontype (STRING), contentduration (INTEGER), contenttype (STRING), enddatetime (STRING), episode (STRING), fulltitle (STRING), genres (STRING), network (STRING), season (STRING), serieid (STRING), serietitle (STRING), startdatetime (STRING), title (STRING), contentid (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_userbillingactivity` table has columns: hashid (INTEGER), amountpublishercurrency (FLOAT), amountsubscribercurrency (FLOAT), country (STRING), countrycode (STRING), monthdate (DATE), paymentmethod (STRING), producttype (STRING), publishercurrency (STRING), region (STRING), regioncode (STRING), subscribercurrency (STRING), subscriptionid (STRING), subscriptionperiod (STRING), userid (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). If asked to display columns that are in different tables, you must perform a join. If information about today's date is requested, the response should include data corresponding to the maximum available date in the table. Similarly, if information about yesterday's date is requested, the response should include data corresponding to the day before the maximum available date in the table. This can be achieved using max(daydate), for example. If a specific error is mentioned, you should repeat the last query while trying to correct the error."}, {"author": "user", "content": "Give me a ranking by countries according to the number of times each country appears, and show me the country, its position in the ranking, and how many times it appears using data from yesterday."}, {"content": "SELECT country, COUNT(*) AS veces_aparece, RANK() OVER (ORDER BY COUNT(*) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` WHERE daydate = DATE_SUB(CURRENT_DATE(), INTERVAL 1 DAY) GROUP BY country ORDER BY ranking ASC;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Could you provide me with a ranking by gender based on their subscription period starting from January 5, 2023?"}, {"content": "SELECT fact_useractivity.gender, fact_registereduser.subscriptionperiod, COUNT(*) AS total, RANK() OVER (ORDER BY COUNT(*) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` AS fact_registereduser JOIN `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` AS fact_useractivity using (userid) WHERE fact_useractivity.gender >= '2023/01/05' GROUP BY fact_useractivity.gender, fact_registereduser.subscriptionperiod ORDER BY ranking asc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Show me the number of subscribed users for each day of January 2023."}, {"content": "SELECT activationdaydate,count(*) FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` WHERE activationdaydate BETWEEN '2023-01-01' AND '2023-01-31' and type = 'Subscription'group by activationdaydate order by activationdaydate asc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Show me the total number of subscriptions for each subscription type, including the total number of subscriptions and the total number of active subscriptions."}, {"content": "with max_start as (SELECT userid,  max(daydate) as mx,subscriptionid FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` where  eventtype='Start' group by subscriptionid,userid), max_end as(SELECT userid,max(daydate) as mx,subscriptionid FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` WHERE  eventtype='End' group by subscriptionid ,userid) select subscriptionid, estado, count(*) as total from(select s.userid, case when s.mx > e.mx then 'activo' else 'inactivo' end  as estado, subscriptionid from max_start s join max_end as e using(subscriptionid, userid)) group by subscriptionid,estado order by total desc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Give me a ranking according to the total content duration for each title today."}, {"content": "SELECT title, SUM(contentduration) as duracion_minutos, RANK() OVER (ORDER BY SUM(contentduration) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` where daydate=(select max(daydate) from `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`)  GROUP BY title ORDER BY ranking ASC;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Give me a ranking of the top 3 most viewed genres of this year."}, {"content": "SELECT genres, count(playbacktime) AS duracion, RANK() OVER (ORDER BY SUM(playbacktime) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`  WHERE EXTRACT(YEAR FROM daydate) = EXTRACT(YEAR FROM (select max(daydate) from `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`)) GROUP BY genres ORDER BY ranking ASC LIMIT 3;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "hello"}, {"content": "Hi, how can I help you?", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}], "hello": [{"author": "system", "content": "Given an input request, respond using Standard SQL in a syntactically correct and valid manner. Diacritical marks (tildes) are not allowed in Standard SQL. Calculate the date using the function max(daydate). Be strict with the date; if it is specified, it is essential to include it. Be creative, but the SQL must be correct. If a ranking is requested, use the rank function and order by the ranking in descending order. Only use the tables named `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_catalogue`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_epg`, and `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_userbillingactivity`. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` has columns: userid (string), daydate (Date), title (String), country (String), contentduration (Integer), playbacktime (Integer). In the fact_playbackactivity table, the columns contentduration and playbacktime are in milliseconds. contentduration represents the total duration of that content, and playbacktime represents the time the user has played that content. When asked for a ranking that includes playbacktime, you should use count(), unless explicitly requested to provide the total time. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` has columns: userid (String), daydate (Date), country (String), email (string), gender (String), eventtype (String), subscriptionid (String). The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` table contains the historical activity of users. The subscriptionid column indicates the subscription type, and the eventtype column has two possible values: Start or End, which indicate the start or end of a subscription. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` has columns: userid (String), daydate (Date), subscriptionperiod (String), deactivationdaydate (Date), activationdaydate (Date), type (String), producttype (String). In the `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` table, a new copy is made every day, so it contains the history for each day. The daydate column indicates the day the row was added. The deactivationdaydate column has two possible values: the same as the daydate column, which indicates that the subscription was canceled on that day, or '2099-12-31', which indicates that the day of the daydate column does not cancel the subscription. When the year is 2099, it means the subscription cannot be canceled, and when the year is 2023, it means the subscription can be canceled on that day. The activationdaydate column indicates the day the user subscribed. The type column indicates the type of record, with two possible values: Registration and Subscription. When a user subscribes, two rows are stored: one with type Subscription and another with type Registration. When the user unsubscribes, the Subscription row is deleted, but the Registration row remains. In the `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registeredused` table, for example, to obtain the total number of active subscriptions from yesterday, you need to filter by active subscriptions from yesterday. This is achieved by using the filter (deactivationdaydate = '2099-12-31'). Additionally, it is necessary to filter by subscriptions of type 'Subscription' and from the last registered day in the fact_registereduser table. The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_catalogue` table has columns: hashid (INTEGER), channel (STRING), consumptiontype (STRING), contentduration (INTEGER), contentid (STRING), contenttype (STRING), countrycode (STRING), episode (STRING), fulltitle (STRING), genres (STRING), isnetworkoriginalcontent (STRING), network (STRING), origin (STRING), publishdate (STRING), regioncode (STRING), season (STRING), serieid (STRING), serietitle (STRING), synopsis (STRING), title (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). The contenttype column in the fact_catalogue table indicates the type of content being played, which can have two possible values: `episode` to indicate an episode of a series, or `MOVIE` to indicate a movie. The fact_epg table has columns: hashid (INTEGER), broadcastingtime (STRING), channel (STRING), channelid (STRING), consumptiontype (STRING), contentduration (INTEGER), contenttype (STRING), enddatetime (STRING), episode (STRING), fulltitle (STRING), genres (STRING), network (STRING), season (STRING), serieid (STRING), serietitle (STRING), startdatetime (STRING), title (STRING), contentid (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_userbillingactivity` table has columns: hashid (INTEGER), amountpublishercurrency (FLOAT), amountsubscribercurrency (FLOAT), country (STRING), countrycode (STRING), monthdate (DATE), paymentmethod (STRING), producttype (STRING), publishercurrency (STRING), region (STRING), regioncode (STRING), subscribercurrency (STRING), subscriptionid (STRING), subscriptionperiod (STRING), userid (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). If asked to display columns that are in different tables, you must perform a join. If information about today's date is requested, the response should include data corresponding to the maximum available date in the table. Similarly, if information about yesterday's date is requested, the response should include data corresponding to the day before the maximum available date in the table. This can be achieved using max(daydate), for example. If a specific error is mentioned, you should repeat the last query while trying to correct the error."}, {"author": "user", "content": "Give me a ranking by countries according to the number of times each country appears, and show me the country, its position in the ranking, and how many times it appears using data from yesterday."}, {"content": "SELECT country, COUNT(*) AS veces_aparece, RANK() OVER (ORDER BY COUNT(*) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` WHERE daydate = DATE_SUB(CURRENT_DATE(), INTERVAL 1 DAY) GROUP BY country ORDER BY ranking ASC;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Could you provide me with a ranking by gender based on their subscription period starting from January 5, 2023?"}, {"content": "SELECT fact_useractivity.gender, fact_registereduser.subscriptionperiod, COUNT(*) AS total, RANK() OVER (ORDER BY COUNT(*) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` AS fact_registereduser JOIN `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` AS fact_useractivity using (userid) WHERE fact_useractivity.gender >= '2023/01/05' GROUP BY fact_useractivity.gender, fact_registereduser.subscriptionperiod ORDER BY ranking asc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Show me the number of subscribed users for each day of January 2023."}, {"content": "SELECT activationdaydate,count(*) FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` WHERE activationdaydate BETWEEN '2023-01-01' AND '2023-01-31' and type = 'Subscription'group by activationdaydate order by activationdaydate asc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Show me the total number of subscriptions for each subscription type, including the total number of subscriptions and the total number of active subscriptions."}, {"content": "with max_start as (SELECT userid,  max(daydate) as mx,subscriptionid FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` where  eventtype='Start' group by subscriptionid,userid), max_end as(SELECT userid,max(daydate) as mx,subscriptionid FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` WHERE  eventtype='End' group by subscriptionid ,userid) select subscriptionid, estado, count(*) as total from(select s.userid, case when s.mx > e.mx then 'activo' else 'inactivo' end  as estado, subscriptionid from max_start s join max_end as e using(subscriptionid, userid)) group by subscriptionid,estado order by total desc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Give me a ranking according to the total content duration for each title today."}, {"content": "SELECT title, SUM(contentduration) as duracion_minutos, RANK() OVER (ORDER BY SUM(contentduration) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` where daydate=(select max(daydate) from `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`)  GROUP BY title ORDER BY ranking ASC;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Give me a ranking of the top 3 most viewed genres of this year."}, {"content": "SELECT genres, count(playbacktime) AS duracion, RANK() OVER (ORDER BY SUM(playbacktime) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`  WHERE EXTRACT(YEAR FROM daydate) = EXTRACT(YEAR FROM (select max(daydate) from `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`)) GROUP BY genres ORDER BY ranking ASC LIMIT 3;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "pepebi\u00f1uelas"}, {"content": "SELECT count(*) FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` WHERE country = 'US';", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "hello"}, {"content": "SELECT COUNT(*) FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` WHERE daydate = DATE_SUB(CURRENT_DATE(), INTERVAL 1 DAY) AND country = 'US';", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}], "firualis": [{"author": "system", "content": "Given an input request, respond using Standard SQL in a syntactically correct and valid manner. Diacritical marks (tildes) are not allowed in Standard SQL. Calculate the date using the function max(daydate). Be strict with the date; if it is specified, it is essential to include it. Be creative, but the SQL must be correct. If a ranking is requested, use the rank function and order by the ranking in descending order. Only use the tables named `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_catalogue`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_epg`, and `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_userbillingactivity`. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` has columns: userid (string), daydate (Date), title (String), country (String), contentduration (Integer), playbacktime (Integer). In the fact_playbackactivity table, the columns contentduration and playbacktime are in milliseconds. contentduration represents the total duration of that content, and playbacktime represents the time the user has played that content. When asked for a ranking that includes playbacktime, you should use count(), unless explicitly requested to provide the total time. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` has columns: userid (String), daydate (Date), country (String), email (string), gender (String), eventtype (String), subscriptionid (String). The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` table contains the historical activity of users. The subscriptionid column indicates the subscription type, and the eventtype column has two possible values: Start or End, which indicate the start or end of a subscription. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` has columns: userid (String), daydate (Date), subscriptionperiod (String), deactivationdaydate (Date), activationdaydate (Date), type (String), producttype (String). In the `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` table, a new copy is made every day, so it contains the history for each day. The daydate column indicates the day the row was added. The deactivationdaydate column has two possible values: the same as the daydate column, which indicates that the subscription was canceled on that day, or '2099-12-31', which indicates that the day of the daydate column does not cancel the subscription. When the year is 2099, it means the subscription cannot be canceled, and when the year is 2023, it means the subscription can be canceled on that day. The activationdaydate column indicates the day the user subscribed. The type column indicates the type of record, with two possible values: Registration and Subscription. When a user subscribes, two rows are stored: one with type Subscription and another with type Registration. When the user unsubscribes, the Subscription row is deleted, but the Registration row remains. In the `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registeredused` table, for example, to obtain the total number of active subscriptions from yesterday, you need to filter by active subscriptions from yesterday. This is achieved by using the filter (deactivationdaydate = '2099-12-31'). Additionally, it is necessary to filter by subscriptions of type 'Subscription' and from the last registered day in the fact_registereduser table. The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_catalogue` table has columns: hashid (INTEGER), channel (STRING), consumptiontype (STRING), contentduration (INTEGER), contentid (STRING), contenttype (STRING), countrycode (STRING), episode (STRING), fulltitle (STRING), genres (STRING), isnetworkoriginalcontent (STRING), network (STRING), origin (STRING), publishdate (STRING), regioncode (STRING), season (STRING), serieid (STRING), serietitle (STRING), synopsis (STRING), title (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). The contenttype column in the fact_catalogue table indicates the type of content being played, which can have two possible values: `episode` to indicate an episode of a series, or `MOVIE` to indicate a movie. The fact_epg table has columns: hashid (INTEGER), broadcastingtime (STRING), channel (STRING), channelid (STRING), consumptiontype (STRING), contentduration (INTEGER), contenttype (STRING), enddatetime (STRING), episode (STRING), fulltitle (STRING), genres (STRING), network (STRING), season (STRING), serieid (STRING), serietitle (STRING), startdatetime (STRING), title (STRING), contentid (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_userbillingactivity` table has columns: hashid (INTEGER), amountpublishercurrency (FLOAT), amountsubscribercurrency (FLOAT), country (STRING), countrycode (STRING), monthdate (DATE), paymentmethod (STRING), producttype (STRING), publishercurrency (STRING), region (STRING), regioncode (STRING), subscribercurrency (STRING), subscriptionid (STRING), subscriptionperiod (STRING), userid (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). If asked to display columns that are in different tables, you must perform a join. If information about today's date is requested, the response should include data corresponding to the maximum available date in the table. Similarly, if information about yesterday's date is requested, the response should include data corresponding to the day before the maximum available date in the table. This can be achieved using max(daydate), for example. If a specific error is mentioned, you should repeat the last query while trying to correct the error."}, {"author": "user", "content": "Give me a ranking by countries according to the number of times each country appears, and show me the country, its position in the ranking, and how many times it appears using data from yesterday."}, {"content": "SELECT country, COUNT(*) AS veces_aparece, RANK() OVER (ORDER BY COUNT(*) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` WHERE daydate = DATE_SUB(CURRENT_DATE(), INTERVAL 1 DAY) GROUP BY country ORDER BY ranking ASC;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Could you provide me with a ranking by gender based on their subscription period starting from January 5, 2023?"}, {"content": "SELECT fact_useractivity.gender, fact_registereduser.subscriptionperiod, COUNT(*) AS total, RANK() OVER (ORDER BY COUNT(*) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` AS fact_registereduser JOIN `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` AS fact_useractivity using (userid) WHERE fact_useractivity.gender >= '2023/01/05' GROUP BY fact_useractivity.gender, fact_registereduser.subscriptionperiod ORDER BY ranking asc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Show me the number of subscribed users for each day of January 2023."}, {"content": "SELECT activationdaydate,count(*) FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` WHERE activationdaydate BETWEEN '2023-01-01' AND '2023-01-31' and type = 'Subscription'group by activationdaydate order by activationdaydate asc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Show me the total number of subscriptions for each subscription type, including the total number of subscriptions and the total number of active subscriptions."}, {"content": "with max_start as (SELECT userid,  max(daydate) as mx,subscriptionid FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` where  eventtype='Start' group by subscriptionid,userid), max_end as(SELECT userid,max(daydate) as mx,subscriptionid FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` WHERE  eventtype='End' group by subscriptionid ,userid) select subscriptionid, estado, count(*) as total from(select s.userid, case when s.mx > e.mx then 'activo' else 'inactivo' end  as estado, subscriptionid from max_start s join max_end as e using(subscriptionid, userid)) group by subscriptionid,estado order by total desc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Give me a ranking according to the total content duration for each title today."}, {"content": "SELECT title, SUM(contentduration) as duracion_minutos, RANK() OVER (ORDER BY SUM(contentduration) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` where daydate=(select max(daydate) from `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`)  GROUP BY title ORDER BY ranking ASC;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Give me a ranking of the top 3 most viewed genres of this year."}, {"content": "SELECT genres, count(playbacktime) AS duracion, RANK() OVER (ORDER BY SUM(playbacktime) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`  WHERE EXTRACT(YEAR FROM daydate) = EXTRACT(YEAR FROM (select max(daydate) from `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`)) GROUP BY genres ORDER BY ranking ASC LIMIT 3;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}]}, "nose": {"default_prompt": [{"author": "system", "content": "Given an input request, respond using Standard SQL in a syntactically correct and valid manner. Diacritical marks (tildes) are not allowed in Standard SQL. Calculate the date using the function max(daydate). Be strict with the date; if it is specified, it is essential to include it. Be creative, but the SQL must be correct. If a ranking is requested, use the rank function and order by the ranking in descending order. Only use the tables named `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_catalogue`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_epg`, and `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_userbillingactivity`. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` has columns: userid (string), daydate (Date), title (String), country (String), contentduration (Integer), playbacktime (Integer). In the fact_playbackactivity table, the columns contentduration and playbacktime are in milliseconds. contentduration represents the total duration of that content, and playbacktime represents the time the user has played that content. When asked for a ranking that includes playbacktime, you should use count(), unless explicitly requested to provide the total time. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` has columns: userid (String), daydate (Date), country (String), email (string), gender (String), eventtype (String), subscriptionid (String). The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` table contains the historical activity of users. The subscriptionid column indicates the subscription type, and the eventtype column has two possible values: Start or End, which indicate the start or end of a subscription. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` has columns: userid (String), daydate (Date), subscriptionperiod (String), deactivationdaydate (Date), activationdaydate (Date), type (String), producttype (String). In the `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` table, a new copy is made every day, so it contains the history for each day. The daydate column indicates the day the row was added. The deactivationdaydate column has two possible values: the same as the daydate column, which indicates that the subscription was canceled on that day, or '2099-12-31', which indicates that the day of the daydate column does not cancel the subscription. When the year is 2099, it means the subscription cannot be canceled, and when the year is 2023, it means the subscription can be canceled on that day. The activationdaydate column indicates the day the user subscribed. The type column indicates the type of record, with two possible values: Registration and Subscription. When a user subscribes, two rows are stored: one with type Subscription and another with type Registration. When the user unsubscribes, the Subscription row is deleted, but the Registration row remains. In the `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registeredused` table, for example, to obtain the total number of active subscriptions from yesterday, you need to filter by active subscriptions from yesterday. This is achieved by using the filter (deactivationdaydate = '2099-12-31'). Additionally, it is necessary to filter by subscriptions of type 'Subscription' and from the last registered day in the fact_registereduser table. The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_catalogue` table has columns: hashid (INTEGER), channel (STRING), consumptiontype (STRING), contentduration (INTEGER), contentid (STRING), contenttype (STRING), countrycode (STRING), episode (STRING), fulltitle (STRING), genres (STRING), isnetworkoriginalcontent (STRING), network (STRING), origin (STRING), publishdate (STRING), regioncode (STRING), season (STRING), serieid (STRING), serietitle (STRING), synopsis (STRING), title (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). The contenttype column in the fact_catalogue table indicates the type of content being played, which can have two possible values: `episode` to indicate an episode of a series, or `MOVIE` to indicate a movie. The fact_epg table has columns: hashid (INTEGER), broadcastingtime (STRING), channel (STRING), channelid (STRING), consumptiontype (STRING), contentduration (INTEGER), contenttype (STRING), enddatetime (STRING), episode (STRING), fulltitle (STRING), genres (STRING), network (STRING), season (STRING), serieid (STRING), serietitle (STRING), startdatetime (STRING), title (STRING), contentid (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_userbillingactivity` table has columns: hashid (INTEGER), amountpublishercurrency (FLOAT), amountsubscribercurrency (FLOAT), country (STRING), countrycode (STRING), monthdate (DATE), paymentmethod (STRING), producttype (STRING), publishercurrency (STRING), region (STRING), regioncode (STRING), subscribercurrency (STRING), subscriptionid (STRING), subscriptionperiod (STRING), userid (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). If asked to display columns that are in different tables, you must perform a join. If information about today's date is requested, the response should include data corresponding to the maximum available date in the table. Similarly, if information about yesterday's date is requested, the response should include data corresponding to the day before the maximum available date in the table. This can be achieved using max(daydate), for example. If a specific error is mentioned, you should repeat the last query while trying to correct the error."}, {"author": "user", "content": "Give me a ranking by countries according to the number of times each country appears, and show me the country, its position in the ranking, and how many times it appears using data from yesterday."}, {"content": "SELECT country, COUNT(*) AS veces_aparece, RANK() OVER (ORDER BY COUNT(*) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` WHERE daydate = DATE_SUB(CURRENT_DATE(), INTERVAL 1 DAY) GROUP BY country ORDER BY ranking ASC;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Could you provide me with a ranking by gender based on their subscription period starting from January 5, 2023?"}, {"content": "SELECT fact_useractivity.gender, fact_registereduser.subscriptionperiod, COUNT(*) AS total, RANK() OVER (ORDER BY COUNT(*) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` AS fact_registereduser JOIN `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` AS fact_useractivity using (userid) WHERE fact_useractivity.gender >= '2023/01/05' GROUP BY fact_useractivity.gender, fact_registereduser.subscriptionperiod ORDER BY ranking asc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Show me the number of subscribed users for each day of January 2023."}, {"content": "SELECT activationdaydate,count(*) FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` WHERE activationdaydate BETWEEN '2023-01-01' AND '2023-01-31' and type = 'Subscription'group by activationdaydate order by activationdaydate asc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Show me the total number of subscriptions for each subscription type, including the total number of subscriptions and the total number of active subscriptions."}, {"content": "with max_start as (SELECT userid,  max(daydate) as mx,subscriptionid FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` where  eventtype='Start' group by subscriptionid,userid), max_end as(SELECT userid,max(daydate) as mx,subscriptionid FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` WHERE  eventtype='End' group by subscriptionid ,userid) select subscriptionid, estado, count(*) as total from(select s.userid, case when s.mx > e.mx then 'activo' else 'inactivo' end  as estado, subscriptionid from max_start s join max_end as e using(subscriptionid, userid)) group by subscriptionid,estado order by total desc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Give me a ranking according to the total content duration for each title today."}, {"content": "SELECT title, SUM(contentduration) as duracion_minutos, RANK() OVER (ORDER BY SUM(contentduration) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` where daydate=(select max(daydate) from `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`)  GROUP BY title ORDER BY ranking ASC;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Give me a ranking of the top 3 most viewed genres of this year."}, {"content": "SELECT genres, count(playbacktime) AS duracion, RANK() OVER (ORDER BY SUM(playbacktime) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`  WHERE EXTRACT(YEAR FROM daydate) = EXTRACT(YEAR FROM (select max(daydate) from `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`)) GROUP BY genres ORDER BY ranking ASC LIMIT 3;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}]}, "test": {"default_prompt": [{"author": "system", "content": "Given an input request, respond using Standard SQL in a syntactically correct and valid manner. Diacritical marks (tildes) are not allowed in Standard SQL. Calculate the date using the function max(daydate). Be strict with the date; if it is specified, it is essential to include it. Be creative, but the SQL must be correct. If a ranking is requested, use the rank function and order by the ranking in descending order. Only use the tables named `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_catalogue`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_epg`, and `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_userbillingactivity`. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` has columns: userid (string), daydate (Date), title (String), country (String), contentduration (Integer), playbacktime (Integer). In the fact_playbackactivity table, the columns contentduration and playbacktime are in milliseconds. contentduration represents the total duration of that content, and playbacktime represents the time the user has played that content. When asked for a ranking that includes playbacktime, you should use count(), unless explicitly requested to provide the total time. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` has columns: userid (String), daydate (Date), country (String), email (string), gender (String), eventtype (String), subscriptionid (String). The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` table contains the historical activity of users. The subscriptionid column indicates the subscription type, and the eventtype column has two possible values: Start or End, which indicate the start or end of a subscription. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` has columns: userid (String), daydate (Date), subscriptionperiod (String), deactivationdaydate (Date), activationdaydate (Date), type (String), producttype (String). In the `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` table, a new copy is made every day, so it contains the history for each day. The daydate column indicates the day the row was added. The deactivationdaydate column has two possible values: the same as the daydate column, which indicates that the subscription was canceled on that day, or '2099-12-31', which indicates that the day of the daydate column does not cancel the subscription. When the year is 2099, it means the subscription cannot be canceled, and when the year is 2023, it means the subscription can be canceled on that day. The activationdaydate column indicates the day the user subscribed. The type column indicates the type of record, with two possible values: Registration and Subscription. When a user subscribes, two rows are stored: one with type Subscription and another with type Registration. When the user unsubscribes, the Subscription row is deleted, but the Registration row remains. In the `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registeredused` table, for example, to obtain the total number of active subscriptions from yesterday, you need to filter by active subscriptions from yesterday. This is achieved by using the filter (deactivationdaydate = '2099-12-31'). Additionally, it is necessary to filter by subscriptions of type 'Subscription' and from the last registered day in the fact_registereduser table. The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_catalogue` table has columns: hashid (INTEGER), channel (STRING), consumptiontype (STRING), contentduration (INTEGER), contentid (STRING), contenttype (STRING), countrycode (STRING), episode (STRING), fulltitle (STRING), genres (STRING), isnetworkoriginalcontent (STRING), network (STRING), origin (STRING), publishdate (STRING), regioncode (STRING), season (STRING), serieid (STRING), serietitle (STRING), synopsis (STRING), title (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). The contenttype column in the fact_catalogue table indicates the type of content being played, which can have two possible values: `episode` to indicate an episode of a series, or `MOVIE` to indicate a movie. The fact_epg table has columns: hashid (INTEGER), broadcastingtime (STRING), channel (STRING), channelid (STRING), consumptiontype (STRING), contentduration (INTEGER), contenttype (STRING), enddatetime (STRING), episode (STRING), fulltitle (STRING), genres (STRING), network (STRING), season (STRING), serieid (STRING), serietitle (STRING), startdatetime (STRING), title (STRING), contentid (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_userbillingactivity` table has columns: hashid (INTEGER), amountpublishercurrency (FLOAT), amountsubscribercurrency (FLOAT), country (STRING), countrycode (STRING), monthdate (DATE), paymentmethod (STRING), producttype (STRING), publishercurrency (STRING), region (STRING), regioncode (STRING), subscribercurrency (STRING), subscriptionid (STRING), subscriptionperiod (STRING), userid (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). If asked to display columns that are in different tables, you must perform a join. If information about today's date is requested, the response should include data corresponding to the maximum available date in the table. Similarly, if information about yesterday's date is requested, the response should include data corresponding to the day before the maximum available date in the table. This can be achieved using max(daydate), for example. If a specific error is mentioned, you should repeat the last query while trying to correct the error."}, {"author": "user", "content": "Give me a ranking by countries according to the number of times each country appears, and show me the country, its position in the ranking, and how many times it appears using data from yesterday."}, {"content": "SELECT country, COUNT(*) AS veces_aparece, RANK() OVER (ORDER BY COUNT(*) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` WHERE daydate = DATE_SUB(CURRENT_DATE(), INTERVAL 1 DAY) GROUP BY country ORDER BY ranking ASC;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Could you provide me with a ranking by gender based on their subscription period starting from January 5, 2023?"}, {"content": "SELECT fact_useractivity.gender, fact_registereduser.subscriptionperiod, COUNT(*) AS total, RANK() OVER (ORDER BY COUNT(*) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` AS fact_registereduser JOIN `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` AS fact_useractivity using (userid) WHERE fact_useractivity.gender >= '2023/01/05' GROUP BY fact_useractivity.gender, fact_registereduser.subscriptionperiod ORDER BY ranking asc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Show me the number of subscribed users for each day of January 2023."}, {"content": "SELECT activationdaydate,count(*) FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` WHERE activationdaydate BETWEEN '2023-01-01' AND '2023-01-31' and type = 'Subscription'group by activationdaydate order by activationdaydate asc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Show me the total number of subscriptions for each subscription type, including the total number of subscriptions and the total number of active subscriptions."}, {"content": "with max_start as (SELECT userid,  max(daydate) as mx,subscriptionid FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` where  eventtype='Start' group by subscriptionid,userid), max_end as(SELECT userid,max(daydate) as mx,subscriptionid FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` WHERE  eventtype='End' group by subscriptionid ,userid) select subscriptionid, estado, count(*) as total from(select s.userid, case when s.mx > e.mx then 'activo' else 'inactivo' end  as estado, subscriptionid from max_start s join max_end as e using(subscriptionid, userid)) group by subscriptionid,estado order by total desc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Give me a ranking according to the total content duration for each title today."}, {"content": "SELECT title, SUM(contentduration) as duracion_minutos, RANK() OVER (ORDER BY SUM(contentduration) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` where daydate=(select max(daydate) from `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`)  GROUP BY title ORDER BY ranking ASC;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Give me a ranking of the top 3 most viewed genres of this year."}, {"content": "SELECT genres, count(playbacktime) AS duracion, RANK() OVER (ORDER BY SUM(playbacktime) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`  WHERE EXTRACT(YEAR FROM daydate) = EXTRACT(YEAR FROM (select max(daydate) from `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`)) GROUP BY genres ORDER BY ranking ASC LIMIT 3;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}], "pepe": [{"author": "system", "content": "Given an input request, respond using Standard SQL in a syntactically correct and valid manner. Diacritical marks (tildes) are not allowed in Standard SQL. Calculate the date using the function max(daydate). Be strict with the date; if it is specified, it is essential to include it. Be creative, but the SQL must be correct. If a ranking is requested, use the rank function and order by the ranking in descending order. Only use the tables named `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_catalogue`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_epg`, and `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_userbillingactivity`. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` has columns: userid (string), daydate (Date), title (String), country (String), contentduration (Integer), playbacktime (Integer). In the fact_playbackactivity table, the columns contentduration and playbacktime are in milliseconds. contentduration represents the total duration of that content, and playbacktime represents the time the user has played that content. When asked for a ranking that includes playbacktime, you should use count(), unless explicitly requested to provide the total time. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` has columns: userid (String), daydate (Date), country (String), email (string), gender (String), eventtype (String), subscriptionid (String). The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` table contains the historical activity of users. The subscriptionid column indicates the subscription type, and the eventtype column has two possible values: Start or End, which indicate the start or end of a subscription. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` has columns: userid (String), daydate (Date), subscriptionperiod (String), deactivationdaydate (Date), activationdaydate (Date), type (String), producttype (String). In the `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` table, a new copy is made every day, so it contains the history for each day. The daydate column indicates the day the row was added. The deactivationdaydate column has two possible values: the same as the daydate column, which indicates that the subscription was canceled on that day, or '2099-12-31', which indicates that the day of the daydate column does not cancel the subscription. When the year is 2099, it means the subscription cannot be canceled, and when the year is 2023, it means the subscription can be canceled on that day. The activationdaydate column indicates the day the user subscribed. The type column indicates the type of record, with two possible values: Registration and Subscription. When a user subscribes, two rows are stored: one with type Subscription and another with type Registration. When the user unsubscribes, the Subscription row is deleted, but the Registration row remains. In the `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registeredused` table, for example, to obtain the total number of active subscriptions from yesterday, you need to filter by active subscriptions from yesterday. This is achieved by using the filter (deactivationdaydate = '2099-12-31'). Additionally, it is necessary to filter by subscriptions of type 'Subscription' and from the last registered day in the fact_registereduser table. The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_catalogue` table has columns: hashid (INTEGER), channel (STRING), consumptiontype (STRING), contentduration (INTEGER), contentid (STRING), contenttype (STRING), countrycode (STRING), episode (STRING), fulltitle (STRING), genres (STRING), isnetworkoriginalcontent (STRING), network (STRING), origin (STRING), publishdate (STRING), regioncode (STRING), season (STRING), serieid (STRING), serietitle (STRING), synopsis (STRING), title (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). The contenttype column in the fact_catalogue table indicates the type of content being played, which can have two possible values: `episode` to indicate an episode of a series, or `MOVIE` to indicate a movie. The fact_epg table has columns: hashid (INTEGER), broadcastingtime (STRING), channel (STRING), channelid (STRING), consumptiontype (STRING), contentduration (INTEGER), contenttype (STRING), enddatetime (STRING), episode (STRING), fulltitle (STRING), genres (STRING), network (STRING), season (STRING), serieid (STRING), serietitle (STRING), startdatetime (STRING), title (STRING), contentid (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_userbillingactivity` table has columns: hashid (INTEGER), amountpublishercurrency (FLOAT), amountsubscribercurrency (FLOAT), country (STRING), countrycode (STRING), monthdate (DATE), paymentmethod (STRING), producttype (STRING), publishercurrency (STRING), region (STRING), regioncode (STRING), subscribercurrency (STRING), subscriptionid (STRING), subscriptionperiod (STRING), userid (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). If asked to display columns that are in different tables, you must perform a join. If information about today's date is requested, the response should include data corresponding to the maximum available date in the table. Similarly, if information about yesterday's date is requested, the response should include data corresponding to the day before the maximum available date in the table. This can be achieved using max(daydate), for example. If a specific error is mentioned, you should repeat the last query while trying to correct the error."}, {"author": "user", "content": "Give me a ranking by countries according to the number of times each country appears, and show me the country, its position in the ranking, and how many times it appears using data from yesterday."}, {"content": "SELECT country, COUNT(*) AS veces_aparece, RANK() OVER (ORDER BY COUNT(*) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` WHERE daydate = DATE_SUB(CURRENT_DATE(), INTERVAL 1 DAY) GROUP BY country ORDER BY ranking ASC;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Could you provide me with a ranking by gender based on their subscription period starting from January 5, 2023?"}, {"content": "SELECT fact_useractivity.gender, fact_registereduser.subscriptionperiod, COUNT(*) AS total, RANK() OVER (ORDER BY COUNT(*) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` AS fact_registereduser JOIN `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` AS fact_useractivity using (userid) WHERE fact_useractivity.gender >= '2023/01/05' GROUP BY fact_useractivity.gender, fact_registereduser.subscriptionperiod ORDER BY ranking asc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Show me the number of subscribed users for each day of January 2023."}, {"content": "SELECT activationdaydate,count(*) FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` WHERE activationdaydate BETWEEN '2023-01-01' AND '2023-01-31' and type = 'Subscription'group by activationdaydate order by activationdaydate asc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Show me the total number of subscriptions for each subscription type, including the total number of subscriptions and the total number of active subscriptions."}, {"content": "with max_start as (SELECT userid,  max(daydate) as mx,subscriptionid FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` where  eventtype='Start' group by subscriptionid,userid), max_end as(SELECT userid,max(daydate) as mx,subscriptionid FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` WHERE  eventtype='End' group by subscriptionid ,userid) select subscriptionid, estado, count(*) as total from(select s.userid, case when s.mx > e.mx then 'activo' else 'inactivo' end  as estado, subscriptionid from max_start s join max_end as e using(subscriptionid, userid)) group by subscriptionid,estado order by total desc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Give me a ranking according to the total content duration for each title today."}, {"content": "SELECT title, SUM(contentduration) as duracion_minutos, RANK() OVER (ORDER BY SUM(contentduration) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` where daydate=(select max(daydate) from `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`)  GROUP BY title ORDER BY ranking ASC;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Give me a ranking of the top 3 most viewed genres of this year."}, {"content": "SELECT genres, count(playbacktime) AS duracion, RANK() OVER (ORDER BY SUM(playbacktime) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`  WHERE EXTRACT(YEAR FROM daydate) = EXTRACT(YEAR FROM (select max(daydate) from `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`)) GROUP BY genres ORDER BY ranking ASC LIMIT 3;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "hello"}, {"content": "Hi! How can I help you?", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}], "juanitoalima\u00f1a": [{"author": "system", "content": "Given an input request, respond using Standard SQL in a syntactically correct and valid manner. Diacritical marks (tildes) are not allowed in Standard SQL. Calculate the date using the function max(daydate). Be strict with the date; if it is specified, it is essential to include it. Be creative, but the SQL must be correct. If a ranking is requested, use the rank function and order by the ranking in descending order. Only use the tables named `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_catalogue`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_epg`, and `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_userbillingactivity`. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` has columns: userid (string), daydate (Date), title (String), country (String), contentduration (Integer), playbacktime (Integer). In the fact_playbackactivity table, the columns contentduration and playbacktime are in milliseconds. contentduration represents the total duration of that content, and playbacktime represents the time the user has played that content. When asked for a ranking that includes playbacktime, you should use count(), unless explicitly requested to provide the total time. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` has columns: userid (String), daydate (Date), country (String), email (string), gender (String), eventtype (String), subscriptionid (String). The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` table contains the historical activity of users. The subscriptionid column indicates the subscription type, and the eventtype column has two possible values: Start or End, which indicate the start or end of a subscription. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` has columns: userid (String), daydate (Date), subscriptionperiod (String), deactivationdaydate (Date), activationdaydate (Date), type (String), producttype (String). In the `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` table, a new copy is made every day, so it contains the history for each day. The daydate column indicates the day the row was added. The deactivationdaydate column has two possible values: the same as the daydate column, which indicates that the subscription was canceled on that day, or '2099-12-31', which indicates that the day of the daydate column does not cancel the subscription. When the year is 2099, it means the subscription cannot be canceled, and when the year is 2023, it means the subscription can be canceled on that day. The activationdaydate column indicates the day the user subscribed. The type column indicates the type of record, with two possible values: Registration and Subscription. When a user subscribes, two rows are stored: one with type Subscription and another with type Registration. When the user unsubscribes, the Subscription row is deleted, but the Registration row remains. In the `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registeredused` table, for example, to obtain the total number of active subscriptions from yesterday, you need to filter by active subscriptions from yesterday. This is achieved by using the filter (deactivationdaydate = '2099-12-31'). Additionally, it is necessary to filter by subscriptions of type 'Subscription' and from the last registered day in the fact_registereduser table. The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_catalogue` table has columns: hashid (INTEGER), channel (STRING), consumptiontype (STRING), contentduration (INTEGER), contentid (STRING), contenttype (STRING), countrycode (STRING), episode (STRING), fulltitle (STRING), genres (STRING), isnetworkoriginalcontent (STRING), network (STRING), origin (STRING), publishdate (STRING), regioncode (STRING), season (STRING), serieid (STRING), serietitle (STRING), synopsis (STRING), title (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). The contenttype column in the fact_catalogue table indicates the type of content being played, which can have two possible values: `episode` to indicate an episode of a series, or `MOVIE` to indicate a movie. The fact_epg table has columns: hashid (INTEGER), broadcastingtime (STRING), channel (STRING), channelid (STRING), consumptiontype (STRING), contentduration (INTEGER), contenttype (STRING), enddatetime (STRING), episode (STRING), fulltitle (STRING), genres (STRING), network (STRING), season (STRING), serieid (STRING), serietitle (STRING), startdatetime (STRING), title (STRING), contentid (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_userbillingactivity` table has columns: hashid (INTEGER), amountpublishercurrency (FLOAT), amountsubscribercurrency (FLOAT), country (STRING), countrycode (STRING), monthdate (DATE), paymentmethod (STRING), producttype (STRING), publishercurrency (STRING), region (STRING), regioncode (STRING), subscribercurrency (STRING), subscriptionid (STRING), subscriptionperiod (STRING), userid (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). If asked to display columns that are in different tables, you must perform a join. If information about today's date is requested, the response should include data corresponding to the maximum available date in the table. Similarly, if information about yesterday's date is requested, the response should include data corresponding to the day before the maximum available date in the table. This can be achieved using max(daydate), for example. If a specific error is mentioned, you should repeat the last query while trying to correct the error."}, {"author": "user", "content": "Give me a ranking by countries according to the number of times each country appears, and show me the country, its position in the ranking, and how many times it appears using data from yesterday."}, {"content": "SELECT country, COUNT(*) AS veces_aparece, RANK() OVER (ORDER BY COUNT(*) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` WHERE daydate = DATE_SUB(CURRENT_DATE(), INTERVAL 1 DAY) GROUP BY country ORDER BY ranking ASC;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Could you provide me with a ranking by gender based on their subscription period starting from January 5, 2023?"}, {"content": "SELECT fact_useractivity.gender, fact_registereduser.subscriptionperiod, COUNT(*) AS total, RANK() OVER (ORDER BY COUNT(*) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` AS fact_registereduser JOIN `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` AS fact_useractivity using (userid) WHERE fact_useractivity.gender >= '2023/01/05' GROUP BY fact_useractivity.gender, fact_registereduser.subscriptionperiod ORDER BY ranking asc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Show me the number of subscribed users for each day of January 2023."}, {"content": "SELECT activationdaydate,count(*) FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` WHERE activationdaydate BETWEEN '2023-01-01' AND '2023-01-31' and type = 'Subscription'group by activationdaydate order by activationdaydate asc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Show me the total number of subscriptions for each subscription type, including the total number of subscriptions and the total number of active subscriptions."}, {"content": "with max_start as (SELECT userid,  max(daydate) as mx,subscriptionid FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` where  eventtype='Start' group by subscriptionid,userid), max_end as(SELECT userid,max(daydate) as mx,subscriptionid FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` WHERE  eventtype='End' group by subscriptionid ,userid) select subscriptionid, estado, count(*) as total from(select s.userid, case when s.mx > e.mx then 'activo' else 'inactivo' end  as estado, subscriptionid from max_start s join max_end as e using(subscriptionid, userid)) group by subscriptionid,estado order by total desc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Give me a ranking according to the total content duration for each title today."}, {"content": "SELECT title, SUM(contentduration) as duracion_minutos, RANK() OVER (ORDER BY SUM(contentduration) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` where daydate=(select max(daydate) from `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`)  GROUP BY title ORDER BY ranking ASC;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Give me a ranking of the top 3 most viewed genres of this year."}, {"content": "SELECT genres, count(playbacktime) AS duracion, RANK() OVER (ORDER BY SUM(playbacktime) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`  WHERE EXTRACT(YEAR FROM daydate) = EXTRACT(YEAR FROM (select max(daydate) from `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`)) GROUP BY genres ORDER BY ranking ASC LIMIT 3;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "92f003d4-9306-43be-a33c-d56c2c2cba79", "uuid": "hello"}, {"content": "SELECT userid, SUM(contentduration) AS duracion_minutos, RANK() OVER (ORDER BY SUM(contentduration) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` WHERE daydate = (select max(daydate) from `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`) GROUP BY userid ORDER BY ranking ASC;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": "", "uuid": "740c9231-45ad-4fae-92db-9a78ac80bb24"}]}, "sergio_test": {"default_prompt": [{"author": "system", "content": "Given an input request, respond using Standard SQL in a syntactically correct and valid manner. Diacritical marks (tildes) are not allowed in Standard SQL. Calculate the date using the function max(daydate). Be strict with the date; if it is specified, it is essential to include it. Be creative, but the SQL must be correct. If a ranking is requested, use the rank function and order by the ranking in descending order. Only use the tables named `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_catalogue`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_epg`, and `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_userbillingactivity`. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` has columns: userid (string), daydate (Date), title (String), country (String), contentduration (Integer), playbacktime (Integer). In the fact_playbackactivity table, the columns contentduration and playbacktime are in milliseconds. contentduration represents the total duration of that content, and playbacktime represents the time the user has played that content. When asked for a ranking that includes playbacktime, you should use count(), unless explicitly requested to provide the total time. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` has columns: userid (String), daydate (Date), country (String), email (string), gender (String), eventtype (String), subscriptionid (String). The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` table contains the historical activity of users. The subscriptionid column indicates the subscription type, and the eventtype column has two possible values: Start or End, which indicate the start or end of a subscription. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` has columns: userid (String), daydate (Date), subscriptionperiod (String), deactivationdaydate (Date), activationdaydate (Date), type (String), producttype (String). In the `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` table, a new copy is made every day, so it contains the history for each day. The daydate column indicates the day the row was added. The deactivationdaydate column has two possible values: the same as the daydate column, which indicates that the subscription was canceled on that day, or '2099-12-31', which indicates that the day of the daydate column does not cancel the subscription. When the year is 2099, it means the subscription cannot be canceled, and when the year is 2023, it means the subscription can be canceled on that day. The activationdaydate column indicates the day the user subscribed. The type column indicates the type of record, with two possible values: Registration and Subscription. When a user subscribes, two rows are stored: one with type Subscription and another with type Registration. When the user unsubscribes, the Subscription row is deleted, but the Registration row remains. In the `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registeredused` table, for example, to obtain the total number of active subscriptions from yesterday, you need to filter by active subscriptions from yesterday. This is achieved by using the filter (deactivationdaydate = '2099-12-31'). Additionally, it is necessary to filter by subscriptions of type 'Subscription' and from the last registered day in the fact_registereduser table. The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_catalogue` table has columns: hashid (INTEGER), channel (STRING), consumptiontype (STRING), contentduration (INTEGER), contentid (STRING), contenttype (STRING), countrycode (STRING), episode (STRING), fulltitle (STRING), genres (STRING), isnetworkoriginalcontent (STRING), network (STRING), origin (STRING), publishdate (STRING), regioncode (STRING), season (STRING), serieid (STRING), serietitle (STRING), synopsis (STRING), title (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). The contenttype column in the fact_catalogue table indicates the type of content being played, which can have two possible values: `episode` to indicate an episode of a series, or `MOVIE` to indicate a movie. The fact_epg table has columns: hashid (INTEGER), broadcastingtime (STRING), channel (STRING), channelid (STRING), consumptiontype (STRING), contentduration (INTEGER), contenttype (STRING), enddatetime (STRING), episode (STRING), fulltitle (STRING), genres (STRING), network (STRING), season (STRING), serieid (STRING), serietitle (STRING), startdatetime (STRING), title (STRING), contentid (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_userbillingactivity` table has columns: hashid (INTEGER), amountpublishercurrency (FLOAT), amountsubscribercurrency (FLOAT), country (STRING), countrycode (STRING), monthdate (DATE), paymentmethod (STRING), producttype (STRING), publishercurrency (STRING), region (STRING), regioncode (STRING), subscribercurrency (STRING), subscriptionid (STRING), subscriptionperiod (STRING), userid (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). If asked to display columns that are in different tables, you must perform a join. If information about today's date is requested, the response should include data corresponding to the maximum available date in the table. Similarly, if information about yesterday's date is requested, the response should include data corresponding to the day before the maximum available date in the table. This can be achieved using max(daydate), for example. If a specific error is mentioned, you should repeat the last query while trying to correct the error."}, {"author": "user", "content": "Give me a ranking by countries according to the number of times each country appears, and show me the country, its position in the ranking, and how many times it appears using data from yesterday."}, {"content": "SELECT country, COUNT(*) AS veces_aparece, RANK() OVER (ORDER BY COUNT(*) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` WHERE daydate = DATE_SUB(CURRENT_DATE(), INTERVAL 1 DAY) GROUP BY country ORDER BY ranking ASC;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Could you provide me with a ranking by gender based on their subscription period starting from January 5, 2023?"}, {"content": "SELECT fact_useractivity.gender, fact_registereduser.subscriptionperiod, COUNT(*) AS total, RANK() OVER (ORDER BY COUNT(*) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` AS fact_registereduser JOIN `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` AS fact_useractivity using (userid) WHERE fact_useractivity.gender >= '2023/01/05' GROUP BY fact_useractivity.gender, fact_registereduser.subscriptionperiod ORDER BY ranking asc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Show me the number of subscribed users for each day of January 2023."}, {"content": "SELECT activationdaydate,count(*) FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` WHERE activationdaydate BETWEEN '2023-01-01' AND '2023-01-31' and type = 'Subscription'group by activationdaydate order by activationdaydate asc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Show me the total number of subscriptions for each subscription type, including the total number of subscriptions and the total number of active subscriptions."}, {"content": "with max_start as (SELECT userid,  max(daydate) as mx,subscriptionid FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` where  eventtype='Start' group by subscriptionid,userid), max_end as(SELECT userid,max(daydate) as mx,subscriptionid FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` WHERE  eventtype='End' group by subscriptionid ,userid) select subscriptionid, estado, count(*) as total from(select s.userid, case when s.mx > e.mx then 'activo' else 'inactivo' end  as estado, subscriptionid from max_start s join max_end as e using(subscriptionid, userid)) group by subscriptionid,estado order by total desc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Give me a ranking according to the total content duration for each title today."}, {"content": "SELECT title, SUM(contentduration) as duracion_minutos, RANK() OVER (ORDER BY SUM(contentduration) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` where daydate=(select max(daydate) from `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`)  GROUP BY title ORDER BY ranking ASC;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Give me a ranking of the top 3 most viewed genres of this year."}, {"content": "SELECT genres, count(playbacktime) AS duracion, RANK() OVER (ORDER BY SUM(playbacktime) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`  WHERE EXTRACT(YEAR FROM daydate) = EXTRACT(YEAR FROM (select max(daydate) from `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`)) GROUP BY genres ORDER BY ranking ASC LIMIT 3;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}], "ranking": [{"author": "system", "content": "Given an input request, respond using Standard SQL in a syntactically correct and valid manner. Diacritical marks (tildes) are not allowed in Standard SQL. Calculate the date using the function max(daydate). Be strict with the date; if it is specified, it is essential to include it. Be creative, but the SQL must be correct. If a ranking is requested, use the rank function and order by the ranking in descending order. Only use the tables named `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_catalogue`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_epg`, and `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_userbillingactivity`. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` has columns: userid (string), daydate (Date), title (String), country (String), contentduration (Integer), playbacktime (Integer). In the fact_playbackactivity table, the columns contentduration and playbacktime are in milliseconds. contentduration represents the total duration of that content, and playbacktime represents the time the user has played that content. When asked for a ranking that includes playbacktime, you should use count(), unless explicitly requested to provide the total time. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` has columns: userid (String), daydate (Date), country (String), email (string), gender (String), eventtype (String), subscriptionid (String). The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` table contains the historical activity of users. The subscriptionid column indicates the subscription type, and the eventtype column has two possible values: Start or End, which indicate the start or end of a subscription. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` has columns: userid (String), daydate (Date), subscriptionperiod (String), deactivationdaydate (Date), activationdaydate (Date), type (String), producttype (String). In the `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` table, a new copy is made every day, so it contains the history for each day. The daydate column indicates the day the row was added. The deactivationdaydate column has two possible values: the same as the daydate column, which indicates that the subscription was canceled on that day, or '2099-12-31', which indicates that the day of the daydate column does not cancel the subscription. When the year is 2099, it means the subscription cannot be canceled, and when the year is 2023, it means the subscription can be canceled on that day. The activationdaydate column indicates the day the user subscribed. The type column indicates the type of record, with two possible values: Registration and Subscription. When a user subscribes, two rows are stored: one with type Subscription and another with type Registration. When the user unsubscribes, the Subscription row is deleted, but the Registration row remains. In the `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registeredused` table, for example, to obtain the total number of active subscriptions from yesterday, you need to filter by active subscriptions from yesterday. This is achieved by using the filter (deactivationdaydate = '2099-12-31'). Additionally, it is necessary to filter by subscriptions of type 'Subscription' and from the last registered day in the fact_registereduser table. The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_catalogue` table has columns: hashid (INTEGER), channel (STRING), consumptiontype (STRING), contentduration (INTEGER), contentid (STRING), contenttype (STRING), countrycode (STRING), episode (STRING), fulltitle (STRING), genres (STRING), isnetworkoriginalcontent (STRING), network (STRING), origin (STRING), publishdate (STRING), regioncode (STRING), season (STRING), serieid (STRING), serietitle (STRING), synopsis (STRING), title (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). The contenttype column in the fact_catalogue table indicates the type of content being played, which can have two possible values: `episode` to indicate an episode of a series, or `MOVIE` to indicate a movie. The fact_epg table has columns: hashid (INTEGER), broadcastingtime (STRING), channel (STRING), channelid (STRING), consumptiontype (STRING), contentduration (INTEGER), contenttype (STRING), enddatetime (STRING), episode (STRING), fulltitle (STRING), genres (STRING), network (STRING), season (STRING), serieid (STRING), serietitle (STRING), startdatetime (STRING), title (STRING), contentid (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_userbillingactivity` table has columns: hashid (INTEGER), amountpublishercurrency (FLOAT), amountsubscribercurrency (FLOAT), country (STRING), countrycode (STRING), monthdate (DATE), paymentmethod (STRING), producttype (STRING), publishercurrency (STRING), region (STRING), regioncode (STRING), subscribercurrency (STRING), subscriptionid (STRING), subscriptionperiod (STRING), userid (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). If asked to display columns that are in different tables, you must perform a join. If information about today's date is requested, the response should include data corresponding to the maximum available date in the table. Similarly, if information about yesterday's date is requested, the response should include data corresponding to the day before the maximum available date in the table. This can be achieved using max(daydate), for example. If a specific error is mentioned, you should repeat the last query while trying to correct the error."}, {"author": "user", "content": "Give me a ranking by countries according to the number of times each country appears, and show me the country, its position in the ranking, and how many times it appears using data from yesterday."}, {"content": "SELECT country, COUNT(*) AS veces_aparece, RANK() OVER (ORDER BY COUNT(*) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` WHERE daydate = DATE_SUB(CURRENT_DATE(), INTERVAL 1 DAY) GROUP BY country ORDER BY ranking ASC;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Could you provide me with a ranking by gender based on their subscription period starting from January 5, 2023?"}, {"content": "SELECT fact_useractivity.gender, fact_registereduser.subscriptionperiod, COUNT(*) AS total, RANK() OVER (ORDER BY COUNT(*) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` AS fact_registereduser JOIN `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` AS fact_useractivity using (userid) WHERE fact_useractivity.gender >= '2023/01/05' GROUP BY fact_useractivity.gender, fact_registereduser.subscriptionperiod ORDER BY ranking asc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Show me the number of subscribed users for each day of January 2023."}, {"content": "SELECT activationdaydate,count(*) FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` WHERE activationdaydate BETWEEN '2023-01-01' AND '2023-01-31' and type = 'Subscription'group by activationdaydate order by activationdaydate asc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Show me the total number of subscriptions for each subscription type, including the total number of subscriptions and the total number of active subscriptions."}, {"content": "with max_start as (SELECT userid,  max(daydate) as mx,subscriptionid FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` where  eventtype='Start' group by subscriptionid,userid), max_end as(SELECT userid,max(daydate) as mx,subscriptionid FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` WHERE  eventtype='End' group by subscriptionid ,userid) select subscriptionid, estado, count(*) as total from(select s.userid, case when s.mx > e.mx then 'activo' else 'inactivo' end  as estado, subscriptionid from max_start s join max_end as e using(subscriptionid, userid)) group by subscriptionid,estado order by total desc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Give me a ranking according to the total content duration for each title today."}, {"content": "SELECT title, SUM(contentduration) as duracion_minutos, RANK() OVER (ORDER BY SUM(contentduration) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` where daydate=(select max(daydate) from `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`)  GROUP BY title ORDER BY ranking ASC;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Give me a ranking of the top 3 most viewed genres of this year."}, {"content": "SELECT genres, count(playbacktime) AS duracion, RANK() OVER (ORDER BY SUM(playbacktime) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`  WHERE EXTRACT(YEAR FROM daydate) = EXTRACT(YEAR FROM (select max(daydate) from `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`)) GROUP BY genres ORDER BY ranking ASC LIMIT 3;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "031008d6-d360-459c-a4c0-790bb5b23ee4", "uuid": "give me a ranking of usuarios registrados en 2022 por pa\u00edses"}, {"content": "SELECT country, SUM(contentduration) as total_minutos, RANK() OVER (ORDER BY SUM(contentduration) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` WHERE daydate=(select max(daydate) from `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`) GROUP BY country ORDER BY ranking ASC;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": "", "uuid": "f028766f-f1ad-4580-9ac9-5fe3294f7c07"}]}, "sergiofa": {"default_prompt": [{"author": "system", "content": "Given an input request, respond using Standard SQL in a syntactically correct and valid manner. Diacritical marks (tildes) are not allowed in Standard SQL. Calculate the date using the function max(daydate). Be strict with the date; if it is specified, it is essential to include it. Be creative, but the SQL must be correct. If a ranking is requested, use the rank function and order by the ranking in descending order. Only use the tables named `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_catalogue`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_epg`, and `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_userbillingactivity`. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` has columns: userid (string), daydate (Date), title (String), country (String), contentduration (Integer), playbacktime (Integer). In the fact_playbackactivity table, the columns contentduration and playbacktime are in milliseconds. contentduration represents the total duration of that content, and playbacktime represents the time the user has played that content. When asked for a ranking that includes playbacktime, you should use count(), unless explicitly requested to provide the total time. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` has columns: userid (String), daydate (Date), country (String), email (string), gender (String), eventtype (String), subscriptionid (String). The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` table contains the historical activity of users. The subscriptionid column indicates the subscription type, and the eventtype column has two possible values: Start or End, which indicate the start or end of a subscription. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` has columns: userid (String), daydate (Date), subscriptionperiod (String), deactivationdaydate (Date), activationdaydate (Date), type (String), producttype (String). In the `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` table, a new copy is made every day, so it contains the history for each day. The daydate column indicates the day the row was added. The deactivationdaydate column has two possible values: the same as the daydate column, which indicates that the subscription was canceled on that day, or '2099-12-31', which indicates that the day of the daydate column does not cancel the subscription. When the year is 2099, it means the subscription cannot be canceled, and when the year is 2023, it means the subscription can be canceled on that day. The activationdaydate column indicates the day the user subscribed. The type column indicates the type of record, with two possible values: Registration and Subscription. When a user subscribes, two rows are stored: one with type Subscription and another with type Registration. When the user unsubscribes, the Subscription row is deleted, but the Registration row remains. In the `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registeredused` table, for example, to obtain the total number of active subscriptions from yesterday, you need to filter by active subscriptions from yesterday. This is achieved by using the filter (deactivationdaydate = '2099-12-31'). Additionally, it is necessary to filter by subscriptions of type 'Subscription' and from the last registered day in the fact_registereduser table. The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_catalogue` table has columns: hashid (INTEGER), channel (STRING), consumptiontype (STRING), contentduration (INTEGER), contentid (STRING), contenttype (STRING), countrycode (STRING), episode (STRING), fulltitle (STRING), genres (STRING), isnetworkoriginalcontent (STRING), network (STRING), origin (STRING), publishdate (STRING), regioncode (STRING), season (STRING), serieid (STRING), serietitle (STRING), synopsis (STRING), title (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). The contenttype column in the fact_catalogue table indicates the type of content being played, which can have two possible values: `episode` to indicate an episode of a series, or `MOVIE` to indicate a movie. The fact_epg table has columns: hashid (INTEGER), broadcastingtime (STRING), channel (STRING), channelid (STRING), consumptiontype (STRING), contentduration (INTEGER), contenttype (STRING), enddatetime (STRING), episode (STRING), fulltitle (STRING), genres (STRING), network (STRING), season (STRING), serieid (STRING), serietitle (STRING), startdatetime (STRING), title (STRING), contentid (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_userbillingactivity` table has columns: hashid (INTEGER), amountpublishercurrency (FLOAT), amountsubscribercurrency (FLOAT), country (STRING), countrycode (STRING), monthdate (DATE), paymentmethod (STRING), producttype (STRING), publishercurrency (STRING), region (STRING), regioncode (STRING), subscribercurrency (STRING), subscriptionid (STRING), subscriptionperiod (STRING), userid (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). If asked to display columns that are in different tables, you must perform a join. If information about today's date is requested, the response should include data corresponding to the maximum available date in the table. Similarly, if information about yesterday's date is requested, the response should include data corresponding to the day before the maximum available date in the table. This can be achieved using max(daydate), for example. If a specific error is mentioned, you should repeat the last query while trying to correct the error."}, {"author": "user", "content": "Give me a ranking by countries according to the number of times each country appears, and show me the country, its position in the ranking, and how many times it appears using data from yesterday."}, {"content": "SELECT country, COUNT(*) AS veces_aparece, RANK() OVER (ORDER BY COUNT(*) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` WHERE daydate = DATE_SUB(CURRENT_DATE(), INTERVAL 1 DAY) GROUP BY country ORDER BY ranking ASC;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Could you provide me with a ranking by gender based on their subscription period starting from January 5, 2023?"}, {"content": "SELECT fact_useractivity.gender, fact_registereduser.subscriptionperiod, COUNT(*) AS total, RANK() OVER (ORDER BY COUNT(*) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` AS fact_registereduser JOIN `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` AS fact_useractivity using (userid) WHERE fact_useractivity.gender >= '2023/01/05' GROUP BY fact_useractivity.gender, fact_registereduser.subscriptionperiod ORDER BY ranking asc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Show me the number of subscribed users for each day of January 2023."}, {"content": "SELECT activationdaydate,count(*) FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` WHERE activationdaydate BETWEEN '2023-01-01' AND '2023-01-31' and type = 'Subscription'group by activationdaydate order by activationdaydate asc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Show me the total number of subscriptions for each subscription type, including the total number of subscriptions and the total number of active subscriptions."}, {"content": "with max_start as (SELECT userid,  max(daydate) as mx,subscriptionid FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` where  eventtype='Start' group by subscriptionid,userid), max_end as(SELECT userid,max(daydate) as mx,subscriptionid FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` WHERE  eventtype='End' group by subscriptionid ,userid) select subscriptionid, estado, count(*) as total from(select s.userid, case when s.mx > e.mx then 'activo' else 'inactivo' end  as estado, subscriptionid from max_start s join max_end as e using(subscriptionid, userid)) group by subscriptionid,estado order by total desc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Give me a ranking according to the total content duration for each title today."}, {"content": "SELECT title, SUM(contentduration) as duracion_minutos, RANK() OVER (ORDER BY SUM(contentduration) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` where daydate=(select max(daydate) from `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`)  GROUP BY title ORDER BY ranking ASC;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Give me a ranking of the top 3 most viewed genres of this year."}, {"content": "SELECT genres, count(playbacktime) AS duracion, RANK() OVER (ORDER BY SUM(playbacktime) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`  WHERE EXTRACT(YEAR FROM daydate) = EXTRACT(YEAR FROM (select max(daydate) from `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`)) GROUP BY genres ORDER BY ranking ASC LIMIT 3;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}], "fa": [{"author": "system", "content": "Given an input request, respond using Standard SQL in a syntactically correct and valid manner. Diacritical marks (tildes) are not allowed in Standard SQL. Calculate the date using the function max(daydate). Be strict with the date; if it is specified, it is essential to include it. Be creative, but the SQL must be correct. If a ranking is requested, use the rank function and order by the ranking in descending order. Only use the tables named `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_catalogue`, `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_epg`, and `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_userbillingactivity`. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` has columns: userid (string), daydate (Date), title (String), country (String), contentduration (Integer), playbacktime (Integer). In the fact_playbackactivity table, the columns contentduration and playbacktime are in milliseconds. contentduration represents the total duration of that content, and playbacktime represents the time the user has played that content. When asked for a ranking that includes playbacktime, you should use count(), unless explicitly requested to provide the total time. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` has columns: userid (String), daydate (Date), country (String), email (string), gender (String), eventtype (String), subscriptionid (String). The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` table contains the historical activity of users. The subscriptionid column indicates the subscription type, and the eventtype column has two possible values: Start or End, which indicate the start or end of a subscription. The table `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` has columns: userid (String), daydate (Date), subscriptionperiod (String), deactivationdaydate (Date), activationdaydate (Date), type (String), producttype (String). In the `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` table, a new copy is made every day, so it contains the history for each day. The daydate column indicates the day the row was added. The deactivationdaydate column has two possible values: the same as the daydate column, which indicates that the subscription was canceled on that day, or '2099-12-31', which indicates that the day of the daydate column does not cancel the subscription. When the year is 2099, it means the subscription cannot be canceled, and when the year is 2023, it means the subscription can be canceled on that day. The activationdaydate column indicates the day the user subscribed. The type column indicates the type of record, with two possible values: Registration and Subscription. When a user subscribes, two rows are stored: one with type Subscription and another with type Registration. When the user unsubscribes, the Subscription row is deleted, but the Registration row remains. In the `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registeredused` table, for example, to obtain the total number of active subscriptions from yesterday, you need to filter by active subscriptions from yesterday. This is achieved by using the filter (deactivationdaydate = '2099-12-31'). Additionally, it is necessary to filter by subscriptions of type 'Subscription' and from the last registered day in the fact_registereduser table. The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_catalogue` table has columns: hashid (INTEGER), channel (STRING), consumptiontype (STRING), contentduration (INTEGER), contentid (STRING), contenttype (STRING), countrycode (STRING), episode (STRING), fulltitle (STRING), genres (STRING), isnetworkoriginalcontent (STRING), network (STRING), origin (STRING), publishdate (STRING), regioncode (STRING), season (STRING), serieid (STRING), serietitle (STRING), synopsis (STRING), title (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). The contenttype column in the fact_catalogue table indicates the type of content being played, which can have two possible values: `episode` to indicate an episode of a series, or `MOVIE` to indicate a movie. The fact_epg table has columns: hashid (INTEGER), broadcastingtime (STRING), channel (STRING), channelid (STRING), consumptiontype (STRING), contentduration (INTEGER), contenttype (STRING), enddatetime (STRING), episode (STRING), fulltitle (STRING), genres (STRING), network (STRING), season (STRING), serieid (STRING), serietitle (STRING), startdatetime (STRING), title (STRING), contentid (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). The `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_userbillingactivity` table has columns: hashid (INTEGER), amountpublishercurrency (FLOAT), amountsubscribercurrency (FLOAT), country (STRING), countrycode (STRING), monthdate (DATE), paymentmethod (STRING), producttype (STRING), publishercurrency (STRING), region (STRING), regioncode (STRING), subscribercurrency (STRING), subscriptionid (STRING), subscriptionperiod (STRING), userid (STRING), yeardate (DATE), brandid (STRING), daydate (DATE). If asked to display columns that are in different tables, you must perform a join. If information about today's date is requested, the response should include data corresponding to the maximum available date in the table. Similarly, if information about yesterday's date is requested, the response should include data corresponding to the day before the maximum available date in the table. This can be achieved using max(daydate), for example. If a specific error is mentioned, you should repeat the last query while trying to correct the error."}, {"author": "user", "content": "Give me a ranking by countries according to the number of times each country appears, and show me the country, its position in the ranking, and how many times it appears using data from yesterday."}, {"content": "SELECT country, COUNT(*) AS veces_aparece, RANK() OVER (ORDER BY COUNT(*) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` WHERE daydate = DATE_SUB(CURRENT_DATE(), INTERVAL 1 DAY) GROUP BY country ORDER BY ranking ASC;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Could you provide me with a ranking by gender based on their subscription period starting from January 5, 2023?"}, {"content": "SELECT fact_useractivity.gender, fact_registereduser.subscriptionperiod, COUNT(*) AS total, RANK() OVER (ORDER BY COUNT(*) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` AS fact_registereduser JOIN `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` AS fact_useractivity using (userid) WHERE fact_useractivity.gender >= '2023/01/05' GROUP BY fact_useractivity.gender, fact_registereduser.subscriptionperiod ORDER BY ranking asc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Show me the number of subscribed users for each day of January 2023."}, {"content": "SELECT activationdaydate,count(*) FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_registereduser` WHERE activationdaydate BETWEEN '2023-01-01' AND '2023-01-31' and type = 'Subscription'group by activationdaydate order by activationdaydate asc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Show me the total number of subscriptions for each subscription type, including the total number of subscriptions and the total number of active subscriptions."}, {"content": "with max_start as (SELECT userid,  max(daydate) as mx,subscriptionid FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` where  eventtype='Start' group by subscriptionid,userid), max_end as(SELECT userid,max(daydate) as mx,subscriptionid FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_useractivity` WHERE  eventtype='End' group by subscriptionid ,userid) select subscriptionid, estado, count(*) as total from(select s.userid, case when s.mx > e.mx then 'activo' else 'inactivo' end  as estado, subscriptionid from max_start s join max_end as e using(subscriptionid, userid)) group by subscriptionid,estado order by total desc;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Give me a ranking according to the total content duration for each title today."}, {"content": "SELECT title, SUM(contentduration) as duracion_minutos, RANK() OVER (ORDER BY SUM(contentduration) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` where daydate=(select max(daydate) from `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`)  GROUP BY title ORDER BY ranking ASC;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "Give me a ranking of the top 3 most viewed genres of this year."}, {"content": "SELECT genres, count(playbacktime) AS duracion, RANK() OVER (ORDER BY SUM(playbacktime) DESC) AS ranking FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`  WHERE EXTRACT(YEAR FROM daydate) = EXTRACT(YEAR FROM (select max(daydate) from `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity`)) GROUP BY genres ORDER BY ranking ASC LIMIT 3;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": ""}, {"author": "user", "content": "b81db1a2-c7a9-4dee-992c-cd649c2a7e80", "uuid": "hello"}, {"content": "SELECT country, count(*) AS total FROM `hallmark-hallmark-pro.hallmark_hallmark_dwh.fact_playbackactivity` GROUP BY country;", "author": "bot", "citationMetadata": {"citations": []}, "feedback": "", "uuid": "26f1c504-4c6b-4ddc-95a2-23e83cacaeef"}]}}